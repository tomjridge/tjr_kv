(** A KV store with an LRU cache frontend. *)


(** {2 Architecture}

{%html: 

<a href="https://imgur.com/yQhDTnG"><img src="https://i.imgur.com/yQhDTnG.png" title="source: imgur.com" width='100%' /></a>


%}

We construct the following...



{3 LRU}

  - q_lru_pc, a msg queue from lru to pcache
  - Lru and lru_state
  - lru_thrd, which takes messages from lru.to_lower to enqueue on
    q_lru_pc; the lru interface itself can be used by many threads safely




{3 Pcache }

  - q_pc_bt, a msg queue from pcache to B-tree
  - Pcache and pcache_state
  - pc_thrd, which takes msgs from q_pc_btree and executes against pcache; also performs detach occasionally and enqueue messages to q_pc_bt


{3 B-tree}

  - B-tree
  - bt_thrd listening to q_pc_btree; also includes root manager functionality

*)

(* old doc?

{3 Functional store thread}

  - this maintains the "global" state, including locks etc
  - the queues are kept separate since they are implemented using
    mutation anyway FIXME perhaps prefer a "functional" version using
    the functional store
  - includes: lru_state; pcache_state; btree_state (a root pointer?)
  - also includes an Lwt_mvar for communication and implementation of
    with_state (?FIXME still true?)
*)

open Tjr_monad.With_lwt
open Lwt_aux  (* provides various msg queues *)
open Std_types
open Kv_intf 
open Intf_v2
open Kv_runtime_config
open Kv_profilers


module type S = sig
  type k[@@deriving bin_io]
  type v[@@deriving bin_io]
  val k_cmp: k -> k -> int
  type r = Std_types.r[@@deriving bin_io]

  val k_size: int
  val v_size: int
  val r_size: int


  (* The following is needed because these types are generated by
     functor applications, which we do later *)
  (* type leaf_stream *)
  (* type kvop_map *)
  (* val kvop_map_ops: (k,(k,v)kvop,kvop_map) Tjr_map.map_ops *)
end

module Make(S:S) = struct
  open S

  (** {2 Message queues} *)
                  
  let q_lru_pc : (k,v) q_lru_pc = Tjr_mem_queue.With_lwt.make_as_object ()  
  let q_pc_bt : (k,v) q_pc_bt = Tjr_mem_queue.With_lwt.make_as_object ()


  (** {2 LRU cache} *)

  module Lru_ = Tjr_lru_cache.Make(struct
      type k = S.k
      let compare = S.k_cmp
      type v = S.v
      type t = lwt
      let monad_ops = monad_ops
      let async = async
      let event_ops = event_ops
    end)
  type mt_state = Lru_.mt_state

  let lru : (k,v,_) Lru.lru = 
    let open Lru in
    let args : (_,_,_) args = 
      object 
        method make_multithreaded_lru=Lru_.make_multithreaded_lru
        method q_lru_pc ()=q_lru_pc
      end
    in
    make_lru args

  let _ : unit = lru#set_initial_state 
      (Lru_.init_state ~max_size:lru_max_size ~evict_count:lru_evict_count)

  let lru_ops = lru#get_lru_ops ()


  (** {2 Pcache and pcache_thread } *)

  let marshalling_config : (k,v,r) Pcache_intf.marshalling_config = 
    (module S)

  module Pcache_ = Tjr_pcache.Make(struct include Std_types include S let marshalling_config = marshalling_config end)

  let pcache = Pcache_.make_as_obj ()
  (* FIXME need to initialize this *)

  (** {2 B-tree/btree ops/bt thread} *)

  module Btree_ = Tjr_btree.Make(struct include Std_types include S let cs = Tjr_btree_examples.Bin_prot_marshalling.make_constants ~blk_sz:blk_sz_4096 ~k_size ~v_size end)

  let args = Btree_thread.(object
               method get_q_pc_bt () = q_pc_bt
               method get_map_ops () = FIXME use a B-tree make targetting an obk
             end)

  module Btree' : sig
    val btree_thread :
      btree_ops:(k, v, blk_id, leaf_stream, lwt) map_ops_with_ls ->
      yield:(unit -> unit Lwt.t) ->
      sleep:(float -> unit Lwt.t) -> unit -> ('a, lwt) m
  end = struct
    (* open Btree_ops *)
    (* open Dummy_btree_implementation *)
    open Kvop


    let [d2b_ea;d2b_eb] = 
      ["d2b_ea";"d2b_eb"] 
      |> List.map intern
    [@@warning "-8"]
    let mark = bt_profiler.mark

    open Msg_pc_bt

    let btree_op_count = ref 0
    let _ : unit = Stdlib.at_exit (fun () ->
        Printf.printf "%s, B-tree op count: %d\n" __MODULE__ (!btree_op_count))

    (** The thread listens at the end of the q_pc_btree for msgs which it
        then runs against the B-tree, and records the new root pair. *)
    let btree_thread ~btree_ops ~yield ~sleep () = 
      let module A = struct

        let bt_sync () = return (Blk_id_as_int.of_int (-1)) (* FIXME *)
          (* return ((failwith "FIXME"):Blk_id_as_int.blk_id) *)

        let Map_ops_with_ls.{ find; insert; delete; _ } = btree_ops

        let rec loop (ops:('k,'v)kvop list) = 
          (* from_lwt(yield()) >>= fun () -> *)  (* FIXME may want to yield occasionally *)
          match ops with
          | [] -> return ()
          | op::ops -> 
            incr btree_op_count;
            (* FIXME more efficient if we dealt with multiple ops eg insert_many *)
            (* NOTE the following do not have callbacks, because they come
               from a flush from the pcache (even if the LRU user
               requested sync... the sync write is to the pcache) *)
            match op with
            | Insert(k,v) -> 
              btree_ops.insert ~k ~v >>= fun () ->
              loop ops
            | Delete k -> 
              btree_ops.delete ~k >>= fun () ->
              loop ops

        let rec read_and_dispatch () =
          (* from_lwt(yield()) >>= fun () -> *)
          mark d2b_ea; 
          q_pc_bt.ops.memq_dequeue q_pc_bt_state >>= fun msg ->
          mark d2b_eb; 
          (* from_lwt(sleep bt_thread_delay) >>= fun () ->  (\* FIXME *\) *)
          (* Printf.printf "btree_thread dequeued: %s\n%!" "-"; *)
          match msg with
          | Find(k,callback) ->
            find ~k >>= fun v ->
            async(fun () -> callback v) >>= fun () ->
            read_and_dispatch ()
          | Detach { ops; new_pcache_root } ->
            loop ops >>= fun () ->
            (* FIXME what to do with the new root? maybe nothing for the
               time being? *)
            (* FIXME what about root pair? *)
            bt_sync () >>= fun ptr ->        
            Printf.printf 
              "New root pair: pcache_root=%d, bt_root=%d\n%!"
              (Blk_id.to_int new_pcache_root)
              (ptr |> Blk_id_as_int.to_int);
            read_and_dispatch ()
      end
      in
      A.read_and_dispatch ()
      
  end
  let btree_thread = Btree'.btree_thread

end


module Int_int_ex = struct

  type leaf_stream = Tjr_btree_examples.Make_2.Int_int_ex.ls

  module Internal = struct
    type k = int
    let compare = Int_.compare
    type v = int

    type nonrec leaf_stream = leaf_stream
    type kvop_map = Tjr_pcache_example.Int_int_ex.kvop_map
    let kvop_map_ops = Tjr_pcache_example.Int_int_ex.kvop_map_ops
  end

  module Internal2 = Make(Internal)

  include Internal2

end
